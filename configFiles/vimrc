" -----------------------------
"  PLUGINS
" -----------------------------
call plug#begin('~/.vim/plugged')

Plug 'sirVer/ultisnips' | Plug 'honza/vim-snippets'
"
" auto close brackets
Plug 'jiangmiao/auto-pairs'
" better c++ highlighting
Plug 'octol/vim-cpp-enhanced-highlight', {'for': 'cpp'}
" php html indent fix
Plug 'siidney/vim-php-html-indent', {'for': ['php', 'html']}
" color scheme
Plug 'sickill/vim-sunburst'
" linting
Plug 'w0rp/ale'

call plug#end()

if has('autocmd')
    filetype plugin indent on
endif

if has('syntax') && !exists('g:syntax:on')
    syntax enable
endif

" -----------------------------
"  GENERAL SETTINGS
" -----------------------------
set exrc                        " use .vimrc files from current dir if present
set showcmd			" visual autocomplete for cmd menu
set secure			" restrict usage for non default .vimrc
set shell=/bin/zsh		" set shell
set encoding=utf-8
set fileencoding=utf-8
set fileformat=unix		" set unix line endings
set fileformats=unix,dos	" line ending order for existing and new buffers
set autoread			" reload files edited outside of vim
set autoindent 			" set indent based on line above
set backspace=indent,eol,start 	" make backspace work
set complete-=1			" enable Ctrl-P Ctrl-N autocomplete
set smarttab
set nrformats-=octal		" Ctrl-A increments Ctrl-X decrements numbers
set ttimeout			" allows key timeouts in command mode
set ttimeoutlen=100		" set timeout length
set ruler			" show line and col number of cursor position
set number			" show line numbers
set undofile			" create <filename>.un~ for undo after file close
set visualbell t_vb=            " turn off system beeps
set omnifunc=syntaxcomplete#Complete

" INDENTATION
set expandtab			" use spaces instead of tabs
set autoindent			" indent based on indentation of line above
set smartindent			" smarter indent for c-like languages
set shiftwidth=4		" when reading, tabs are 4 spaces
set softtabstop=4		" insert mode tabs are 4 spaces
set wrap                        " wrap long lines

" limit line width to 80 and hightlight col 80
if !&textwidth
    set textwidth=80
    if(exists('+colorcolumn'))
        set colorcolumn=81
        highlight ColorColumn ctermbg=8
    endif
endif

if !&scrolloff
    set scrolloff=1		" disables set number of lines around cursor
endif

if !&sidescrolloff
    set sidescrolloff=1		" disables set number of lines around cursor
endif

if &history < 1000
    set history=1000		" save last 1000 changes
endif

set display+=lastline		" show as much as possible of last line

let g:mapleader=','		" remap leader key

" File Browsing
if !exists('g:newtw_banner')
    let g:netrw_banner=0        " disable banner
endif

if !exists('g:netrw_liststyle')
    let g:netrw_liststyle=3     " change explorer style to tree
endif

" -----------------------------
"  COLOURS
" -----------------------------
set t_Co=256
set background=dark
colorscheme Sunburst

" -----------------------------
"  STATUS LINE
" -----------------------------
let g:modes = {'n':'NORMAL', 'i':'INSERT', 'R':'REPLACE', 'v':'VISUAL', 'V':'V-LINE', '':'V-BLOCK'}

function! ModifiedColour()
    if mode() ==# 'i'
        hi statusline ctermfg=0 ctermbg=3
    else
        if &modified == 1
            hi statusline ctermfg=0 ctermbg=51
        else
            hi statusline ctermfg=15 ctermbg=8
        endif
    endif
    return ''
endfunction

if v:version >= 700
    augroup statusline
        au!
        au InsertEnter * exec ModifiedColour()
        au InsertLeave * exec ModifiedColour()
        au BufWritePost * exec ModifiedColour()
    augroup END
endif

hi statusline ctermfg=15 ctermbg=8

set laststatus=2            " always show status line

set statusline=
set statusline+=%{ModifiedColour()}
set statusline+=\ [%{get(modes,mode())}]                " show modes
set statusline+=\ %<%f                                  " filepath
set statusline+=\ %([%R%M%H]%)                          " readonly modified helpfile
" right side
set statusline+=%=
set statusline+=\%{strlen(&ft)?&ft:'none'}\ \|          " file type
set statusline+=\ %{&fileformat}\ \|                    " file format
set statusline+=\ %{(&fenc!=''?&fenc:&enc)}\ \|         " file encoding
set statusline+=\ BUF\ #%n\ \|                          " buffer number
set statusline+=\ %l/%L                                 " current/total lines
set statusline+=\ (%P)\ \|                              " percentage through file
set statusline+=\ COL%4c\                               " column number

" -----------------------------
"  SEARCHING
" -----------------------------
set path+=**                    " tab-completion for all file-related tasks
set wildmenu			" visual autocomplete for cmd menu
set showmatch			" highlight matching [{()}]
set incsearch			" highlight matches as characters entered
set hlsearch			" highlight matches

" clear search
if maparg('<silent><leader><space>', 'n') ==# ''
nnoremap <silent> <leader><space> :noh<CR>
endif

" -------------------------------
"  KEY BINDINGS
" -------------------------------
"  buffers
" list open buffers and prompt to switch
nnoremap <F5> :ls<CR>:b<space>
" open new empty buffer
nnoremap <leader>B :enew<CR>
" move to next buffer
nnoremap <leader>l :bnext<CR>
" move to previous buffer
nnoremap <leader>h :bprevious<CR>

" netrw
nnoremap <silent> <F6> :Lexplore<CR>    " <F6> explorer

" disable arrow keys
noremap <up> <nop>
noremap <down> <nop>
noremap <left> <nop>
noremap <right> <nop>

inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>

" <F8> View rendered markdown with grip
nnoremap <F8> <Esc>:!grip -b %<CR><CR>

" <F9> insert timestamp (normal and insert mode)
nnoremap <F9> "=strftime("%d/%m/%y %H:%M:%S")<CR>P
inoremap <F9> <C-R>=strftime("%d/%m/%y %H:%M:%S")<CR>

" jk to exit insert mode
imap jk <Esc>

" reload vimrc
nmap <silent> <leader>sv :so $MYVIMRC<CR>

" save file
nnoremap <leader>s :w<CR>
inoremap <leader>s <C-c>:w<CR>

" enter command line mode
nnoremap <Space>  :

" xclip
" pipe contents of paste buffer to xclip
nnoremap <silent><leader>xo :call system('xclip', @0)<CR>

" add contentes of xclip to x register
" paste contents of x register inline
function! XclipO()
    let @x=system('xclip -o')
    normal! "xp
endfunction

nnoremap <silent><leader>xi :call XclipO()<CR>
inoremap <silent><leader>xi <esc>:call XclipO()<CR>i

" -----------------------------
"  WINDOW SPLITS
" -----------------------------
set splitbelow      " :split sets new window below current
set splitright      " :vsplit sets new window to right of current

" -----------------------------
"  PLUGINS
" -----------------------------
" ultisnips
let g:UltiSnipsExpandTrigger='<TAB>'
let g:UltiSnipsJumpForwardTrigger='<TAB>'
let g:UltiSnipsJumpBackwardTrigger='<S-TAB>'

" split window
let g:UltiSnipsEditSplit='vertical'

" ale
let g:ale_linters = {
\    'javascript': ['eslint']
\}

let g:ale_sign_column_always = 1
let g:ale_sign_error = '>>'
let g:ale_sign_warning = '--'

" ----------------------------
"  FILETYPE SETS
" ----------------------------
augroup filetype_set
    au!
    au BufNewFile,BufRead *.endfile set filetype=endfile
augroup END

" ----------------------------
"  STRIP WHITESPACE
" ----------------------------
highlight default ExtraWhitespace ctermbg=darkred

augroup whiteSpace_highlight
    au!
    au ColorScheme * highlight ExtraWhitespace ctermbg=darkred
augroup END

" show trailing whitespace
:match ExtraWhitespace /\s\+\%#\@<!$/

augroup whiteSpace
    au!
    au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
    au InsertLeave * match ExtraWhitespace /\s\+$/
augroup END

function! g:StripWhitespace()
    let l:save_cursor = winsaveview()
    %s/\s\+$//e
    call winrestview(l:save_cursor)
endfunction

command! StripWhitespace call StripWhitespace()

" ----------------------------
"  TEMPLATE FILES
" ----------------------------
function! Template()
    " read in template files
    let l:filepath = '$HOME/.vim/templates/skel.'.expand('%:e')
    " ensure file exists
    if filereadable(expand(l:filepath))
        silent! execute '0r $HOME/.vim/templates/skel.'.expand('<afile>:e')
        " parse special text in templates after read
        %substitute#\[:VIM_EVAL:\]\(.\{-\}\)\[:END_EVAL:\]#\=eval(submatch(1))#ge

        " go to end of description line and enter insert mode
        let l:desc = search('Description')
        if l:desc > 0
            execute 'normal! :cursor(desc)<CR>'
        else
            execute 'normal! G'
        endif
        execute ':startinsert!'
    endif
endfunction

augroup templates
    au!
    au BufNewfile * call Template()
augroup END
